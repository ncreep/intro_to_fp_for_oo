<!DOCTYPE html>
<html>
<head>
<title>Introduction to Functional Design for OO Programmers</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel='stylesheet' type='text/css' href='style.css' />
</head>
<body>
<textarea id="source">

class: center, middle, transition, intro

# Introduction to Functional <br /> Design for  OO Programmers

.introFloat[Daniel Beskin]
---
class: center, middle

The full code can be found at:

https://github.com/ncreep/intro_to_fp_for_oo

???

- This is going to be an introduction to some not so basic Functional programming concepts, from the point of view of an OO programmer.
- I'll be assuming that you're familiar with Object Oriented Design
- I'll be assuming that you are comfortable with the more basic concepts like recursion and higher order functions.
- If not, we have a quick warm up ahead of us, so I hope you do get up to speed.

---

layout: true
## Intro

---

Why Functional Programming?

* Composability
* Powerful abstractions
* Concurrency
* Scalability
* Elegance
* Mathematical inclination
* ...

???

- I'm guessing that if you came here, you probably have a reason to be interested in FP.
- So I won't spend much time convincing you about it.
- Pick any one of the reasons here, or others, and just hold on to it during the lecture

---

Putting the usage of (pure) functions to the forefront

???
- A natural question in this context is: what do I mean when I say Functional Programming?
- Just as with Object Orientation, there is no real consensus on what that is.
- For our purposes, it's just going to be a programming style that puts the usage of (pure) functions to the forefront.
- Not a very useful definition, but that will have to do.

--

For example:
* Anonymous functions
* Higher-order functions
* Recursion

--

How do you build anything with this?

???
- And as you make your first step into this world you probably learned about things like anonymous functions, higher-order functions and recursion
- These are all very powerful techniques.
- But coming from the world object-oriented programming, you might find yourself thinking, how do I build anything with these building blocks? 
- That is, how do we design bigger programs when all we have are just functions?
- In this talk, we will try to take some steps towards answering this question

---
layout: false
class: middle, transition

> ― What are the design patterns that help structure functional<br />&nbsp;&nbsp;&nbsp;&nbsp; systems?
>
> ― Design patterns? Hey everyone, look at the muggle try to get <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the wand to work!

.footnote[[Larry O Brien - Functional programming’s smugness problem](https://sdtimes.com/functional-programming/code-watch-functional-programmings-smugness-problem/)]

???
- One of the most common tools to go to when thinking about program design in the object-oriented world is design patterns
- But as you might have gathered, design-patterns aren't much talked about in the context of functional programming
- As this quote shows, they are even considered somewhat unnecessary
- So what we'll do in this talk, is to look at some well-known design patterns and see how we tackle the same problems in a functional way
- This should give us some insight into the design of functional programs  
---

layout: true

## Warm-up: Iterator

---

???
- We are going to start with some simple and hopefully familiar examples as warm-up
- We will gradually move to more advanced topics, so I hope that everyone will find something of interest in this talk
--

An OO iterator

```
case class Bug(c: Code)
case class Feature(c: Code)

val bugs: List[Bug] = 
  List(Bug("null"), Bug("???"), Bug("var x = 3"))

val bugsIter = bugs.iterator
val featureBuffer = ListBuffer[Feature]()

while(bugsIter.hasNext) {
  featureBuffer += Feature(bugsIter.next().c)
}

val features = featureBuffer.toList

// => List(Feature(null), Feature(???), Feature(var x = 3))
```

???
- This is a very basic example of using an Iterator in an OO setting
- The code describes the magical process by which bugs become features
- The code itself is quite straightforward: 
- Given a list of bugs we iterate over them and turn them into features
- But the code is a bit verbose, we have all this ceremony with the `while` loop
- While the essence of the code is this one line, which is now a bit hard to find

---

An FP (internal) iterator

```
val features: List[Feature] = 
  bugs map (b => Feature(b.c))

// => List(Feature(null), Feature(???), Feature(var x = 3))

{{content}}
```
???
- The Functional alternative is to use an "internal" iterator
- That is, we delegate the management of the iteration itself to someone else
- We just pass the essential data in form of a function
- In this case, the boilerplate is minimal, and it's quite easy to see the essence of the code

--
val features2: List[Feature] = 
  for (b <- bugs) yield Feature(b.c)

???
- Also, in Scala, we have the `for`-comprehension syntax, which is equivalent to the above
- And in some cases may be more readable
---

Iteration combinators

```
case class Programmer(assignedBugs: List[Bug])

val bugs1 = List(Bug("null"), Bug("???"), Bug("var x = 3"))
val p1 = Programmer(bugs1)
val bugs2 = List(Bug("foo.asInstanceOf[Bar]"), Bug("1 = 2"))
val p2 = Programmer(bugs2)

val ps = List(p1, p2)

val allFeatures: List[Feature] =
  ps flatMap (p => p.assignedBugs map (b => Feature(b.c)))

{{content}}
```

???
- Another benefit of using the Functional approach, is that we can build more complicated things on top of it
- In this example, we do nested iteration using the `flatMap` function
- Here, each programmer has some assigned bugs, and we have a list of programmers
- We want to turn all available bugs into features
- So we `flatMap` over the programmers list, and for every bug they have, we reuse the previous `map` invocation

--
val allFeatures2 = for {
  p <- ps
  b <- p.assignedBugs
} yield Feature(b.c)

// List(Feature(null), Feature(???), Feature(var x = 3),
//      Feature(foo.​asInstanceOf[Bar]), Feature(1 = 2))

???

- This is somewhat more readable with a `for`
- Again, we are not dealing with the iteration, we just write the essence of the code that we need
- And this gives us reuse, since we can use the functions being mapped in other contexts as well (unlike the external iterator approach)

---

layout: true

## Warm-up: Null Object

---
Dealing with missing values

```
val compiledCode = {
  val coffee = getCoffee()
  if (coffee == null) null
  else {
    val code = coffee.writeCode()
    if (code == null) null
    else code.tryCompile()
  }
}
```

???

- Next stop, dealing with `null`s
- In a language where `null`s are being used constantly, we have to guard our code against them
- Which makes our code noisy with various `null` checks all over the place
- Here we have the process of code writing, where we assume that in order to write code, one needs coffee
- The `getCoffee` function may return `null` when there isn't any coffee
- And the `writeCode` method may return `null` if there isn't enough coffee to produce code
- All these `null` checks are distracting from the essence of the code

```
val compiledCpodep = {
  val coffee = getCoffee()
  if (coffee == null) null
  else {
    val code = coffee.writeCode()
    if (code == null) null
    else code.tryCompile()
  }
}

// either 'null' or 'Compiled(3 coffee => code)'

def getCoffee(): Coffee = choose(Coffee(3), null)

// choose a random item from the two
def choose[A](x: A, y: A): A = if (util.Random.nextDouble() < 0.5) x else y

case class Coffee(amount: Int) {
  def writeCode(): Code = choose(Code(s"$amount coffee => code"), null)
}

case class Code(code: String) {
  def tryCompile(): Compiled = choose(Compiled(code), null)
}

case class Compiled(code: String)
```

---

Using Null Objects

```
val compiledCode = getCoffee().writeCode().tryCompile()

// either 'NotCompiled' or 'RealCompiled(3 coffee => code)'
```

???
- There is a design pattern called the Null Object
- Where for a type that can be somehow missing we define a special subtype that represents an empty or default value
- With this approach we can cleanup our pervious code into this
- Here, the flow of the code is clean and obvious
- The result here is either some compiled code (when all values are present), or a default missing value (when something's missing)
- But there's a price, boilerplate

--

The boilerplate
.tinyCode[
```
trait Coffee { def writeCode(): Code }
case class RealCoffee(amount: Int) extends Coffee {
  def writeCode(): Code = choose(RealCode(s"$amount coffee => code"), NoCode)
}
case object NoCoffee extends Coffee { def writeCode(): Code = NoCode }

trait Code { def tryCompile(): Compiled }
case class RealCode(code: String) extends Code {
  def tryCompile(): Compiled = choose(RealCompiled(code), NotCompiled)
}
case object NoCode extends Code { def tryCompile(): Compiled = NotCompiled }

trait Compiled
case class RealCompiled(code: String) extends Compiled
case object NotCompiled extends Compiled

def getCoffee(): Coffee = choose(RealCoffee(3), NoCoffee)
```
]
???

- For each type in the code, we need a trait and a real and default implementation
- Null objects are safer, but require way too much boilerplate for every case. In return:
  * we don't get any help from the compiler (the compiler can't tell apart the different instances of a trait)
  * there is no generic way to compose different null objects
- Let's look at the FP alternative, `Option`
---

The FP alternative

```
val compiledCode: Option[Compiled] =
  getCoffee() flatMap { coffee =>
    coffee.writeCode() flatMap { code =>
      code.tryCompile()
    }
  }

// either 'None' or 'Some(Compiled(3 coffee => code))'
```

???

- Instead of using `null`s or having special missing values, we use the `Option` type
- The `flatMap`s let us dig into the optional values and manipulate their contents
- Now there isn't any special boilerplate, since `Option` is generic and can be used in any context

---

```
def getCoffee(): Option[Coffee] = 
  choose(Some(Coffee(3)), None)

case class Coffee(amount: Int) {
  def writeCode(): Option[Code] =
    choose(Some(Code(s"$amount coffee => code")), None)
}

case class Code(code: String) {
  def tryCompile(): Option[Compiled] =
    choose(Some(Compiled(code)), None)
}

case class Compiled(code: String)
```

???
- Every time we a value is missing we return `None`
- All the special case handling is wrapped inside the `map` and `flatMap` methods
- We can also slightly simplify the code by using `for` notation
---

Using `for` notation

```
val compiledCode: Option[Compiled] =
  for {
    coffee <- getCoffee
    code <- coffee.writeCode()
    compiled <- code.tryCompile()
  } yield compiled

```

???

- `Option` is like a list of 0 or 1 items, we can use the `for` notation from before.
- The benefit here is that now the compiler know that we might have a missing case
- So we can't accidentally call a method that might not be present
- And there's a clear distinction between a possibly missing value and an always present one
- And thanks to the use of higher-order functions, the boilerplate is minimal

---
layout: false
class: center, middle, transition

.morpheus[![](morpheus.jpg)]

---
layout: true

## The Decorator Pattern

---

???

- The decorator pattern is used to create different combinations of object behaviors.

- Probably the most Scala-esque way to achieve this is the [stackable trait pattern](http://www.artima.com/scalazine/articles/stackable_trait_pattern.html).

- But we'll stick to the more conventional version of the pattern.

---

A model of a programmer

```
trait Programmer {
  def price: Money
  def makeCode(coffee: Coffee): LOC
  def acceptProject(l: Language): Boolean
}
```

???
- So we'll continue modeling programmers
- In this case a programmer has three methods:
  * A price
  * The ability to turn coffee into lines of code
  * And accepting or rejecting a project based on its language

---

An implementation

```
class BasicProgrammer(experience: XPPoints,
                      coffeeConsumption: Coffee,
                      languages: Set[Language]) 
  extends Programmer {

  def price: Money = experience * languages.size

  // more coffee -> more code
  def makeCode(c: Coffee): LOC =
    experience * math.max(0, c - coffeeConsumption)

  def acceptProject(l: Language): Boolean = languages(l)
}
```

???

- We start with the basic implementation of the programmer trait
- We'll base the implementation on the following data about the programmer:
  * The amount of experience
  * The coffee consumption
  * The languages that the programmer knows
- The implementation is straightforward
  * The more experience and languages that the programmer has, the higher the price
  * More experienced programmers produce more code with the same amount of coffee
  * Whether to accept a project or not depends on whether we know the language used in the project
- To actually implement the decorator, we'll need a simple forwarding implementation
---

A decorator 
```
abstract class ProgrammerDecorator(p: Programmer) 
  extends Programmer {
  
  def price: Money = p.price
  
  def makeCode(c: Coffee): LOC = 
    p.makeCode(c)
    
  def acceptProject(l: Language): Boolean = 
    p.acceptProject(l)
}
```
???
- This programmer just forwards all method calls to another `Programmer`
- Thus allowing us to combine different programmer implementations together
---

Concrete decorators

```
// a programmer that writes tests
class TestingProgrammer(p: Programmer) 
  extends ProgrammerDecorator(p) {
  
  override def price: Money = super.price * 2
  
  override def makeCode(c: Coffee): LOC = 
    super.makeCode(c - 5) * 3
}

// a programmer that writes documentation
class DocumentingProgrammer(p: Programmer) 
  extends ProgrammerDecorator(p) {
  
  override def price: Money = super.price * 10
}

```

???
- Now we can create decorators
- Each one extends the `ProgrammerDecorator` class, so as to forward all un-overridden methods
- We have:
  * A programmer that writes many tests: more expensive and writes way more code
  * A documenting programmer: more expensive for the same amount of code

---
Concrete decorators

```
class SaneProgrammer(p: Programmer) 
  extends ProgrammerDecorator(p) {
  
  override def acceptProject(l): Boolean =
    if (l == "PHP") false
    else super.acceptProject(l)
}

// a programmer that likes learning new languages
class PolyglotProgrammer(p: Programmer) 
  extends ProgrammerDecorator(p) {
  
  override def acceptProject(l): Boolean = 
    !super.acceptProject(l)
}
```
???
* A sane programmer: that just refuses to accept PHP projects
* A polyglot programmer: just likes to learn more languages and accepts anything with a new language

---

Using decorators

```
val base = new BasicProgrammer(
  experience = 10,
  coffeeConsumption = 30,
  languages = Set("Scala", "Java", "PHP"))

val saneDocTest =
  new SaneProgrammer(
    new DocumentingProgrammer(
      new TestingProgrammer(base)))

val documentingPolyglot =
  new PolyglotProgrammer(
    new DocumentingProgrammer(base))
```

???

- We can create different `Programmer`s by combining the different decorators
---

Using decorators

```
base.price // 30
base.makeCode(40) // 100
base.acceptProject("PHP") // true

saneDocTest.price // 600
saneDocTest.makeCode(40) // 150
saneDocTest.acceptProject("PHP") // false

documentingPolyglot.price // 300
documentingPolyglot.makeCode(40) // 100
documentingPolyglot.acceptProject("PHP") // false
```

???
- And then actually use them with the expected results
---

Converting from OO to FP
<table class="codeTable">
<code class="remark-inline-code"></code>
<tr>
  <td><code class="remark-inline-code">prog.price()</code></td>
  <td><code class="remark-inline-code">&nbsp;-->&nbsp;</code></td>
  <td><code class="remark-inline-code">price(prog)</code></td>
</tr>
<tr>
  <td><code class="remark-inline-code">prog.makeCode(coffee)</code></td>
  <td><code class="remark-inline-code">&nbsp;-->&nbsp;</code></td>
  <td><code class="remark-inline-code">makeCode(prog, coffee)</code></td></tr>
<tr>
  <td><code class="remark-inline-code">prog.acceptProject(lang)</code></td>
  <td><code class="remark-inline-code">&nbsp;-->&nbsp;</code></td>
  <td><code class="remark-inline-code">acceptProject(prog, lang)</code></td></tr>
</table>

???

- Now, let's look at this problem from a Functional perspective.
- We need to rephrase the problem in terms of functions that are separate from the data they operate on.
- Because of the implicit `this`, we can view method calls as functions
- Like the following:
  * The `price` method becomes a function that takes a programmer instance and produces the price
  * The `makeCode` method is a bit more complicated, since it takes an argument, but the principle is the same:  
    take a programmer and the other argument and produce a result
  * Same for the `acceptProject` method
  
--

With types
<table class="codeTable">
<tr>
  <td><code class="remark-inline-code">prog.price(): Money</code></td>
  <td><code class="remark-inline-code">&nbsp;-->&nbsp;</code></td>
  <td><code class="remark-inline-code">Programmer => Money</code></td>
</tr>
<tr>
  <td><code class="remark-inline-code">prog.makeCode(c: Coffee): LOC</code></td>
  <td><code class="remark-inline-code">&nbsp;-->&nbsp;</code></td>
  <td><code class="remark-inline-code">Programmer => (Coffee => LOC)</code></td>
</tr>
<tr>
  <td><code class="remark-inline-code">prog.acceptProject(l: Language): Boolean</code></td>
  <td><code class="remark-inline-code">&nbsp;-->&nbsp;</code></td>
  <td><code class="remark-inline-code">Programmer => (Language => Boolean)</code></td>
</tr>
</table>

???
- Since we are working in a typed language, we can spell out the types of the functions that we need
- It's sometimes easier to figure out solutions to problems when we zoom out to the types
- In this case all functions take an input programmer and produce some result
- We are writing the functions in what is called "curried" style
- Instead of accepting two arguments, we accept one and then produce a function that accepts the following argument
- This makes the signatures more uniform and will be handy later on
- So the `makeCode` function takes a programmer and produces a function that given coffee, produces code
---

Chaining

.codeTableSmall[
`TestingProgrammer(DocumentingProgrammer(prog)).price()`

`-->`

`testPrice(docPrice(price(prog)))`
]

???
- We can try to translate a decorated instance into the Functional style
- We start out with the regular function, this produces some money value
- Then we take that value and transform it with the documentation price
- And then the resulting price is transformed for the tests price
- This can be a bit clearer with just the types

--

With types

.codeTableSmall[
`TestingProgrammer(DocumentingProgrammer(prog)).price()`

`-->`

`(Programmer => Money) andThen (Money => Money) andThen (Money => Money)`
]

.gap.codeTableSmall[
`(f andThen g)(x) == g(f(x))`
]

???

- In here we use the function composition operator `andThen`, which takes two functions and chains them
- On the left is the original function
- Then comes the decorating function, it starts with the value from the previous function and produces a new one
- And the same for the second decorator
- Viewed this way, the call to `super` in the decorator is like function chaining
- So decoration is (almost) function composition
- Let's code it up

---
FP `Programmer`

```
case class Programmer(experience: XPPoints,
                      coffeeConsumption: Coffee,
                      languages: Set[Language])
```

```
val price: Programmer => Money =
  p =>
    p.experience * p.languages.size

val makeCode: Programmer => (Coffee => LOC) =
  p => c => 
    p.experience * math.max(0, c - p.coffeeConsumption)

val acceptProject: Programmer => (Language => Boolean) =
  p => l =>
    p.languages(l)
```

???
- Here, the programmer is just a simple data type with no functions
- All of the functionality is in stand-alone functions
- This is just a straight-forward rewrite of the methods that we had before
- Notice the currying, instead of receiving two arguments, we receive one and produce a function that takes the second one

---

Using it

```
val p = Programmer(
  experience = 10,
  coffeeConsumption = 30,
  languages = Set("Scala", "Java", "PHP"))

price(p) // 30
makeCode(p)(40) // 100
acceptProject(p)("PHP") // true
```

???
- Using the functions is simple, just apply the to the programmer instance
- The results are the same as before
- We can now code the decorators

---

The decorators
```
val testPrice: Money => Money =
  m => m * 2

val docPrice: Money => Money =
  m => m * 10

val testMakeCode: 
  (Coffee => LOC) => (Coffee => LOC) =
  mc =>
    c => mc(c - 5) * 3
```

???
- As we said, each decorator take the output of the original programmer function and produces a new output
- The price decorators are the simplest: just take the money we got and do something with it
- The `makeCode` decorator is slightly more complicated
- Here we are not just getting a value from the programmer function, the result is a function by itself
- So the decorator needs to produce a new function
- The `testMakeCode` function take a code making function, and uses it to produce a new code making function
- Just like `super` call let's us access the functionality of the class that we are decorating
- And the same for the other two decorators
---

The decorators
```
val saneAccept: 
  (Language => Boolean) => (Language => Boolean) =
  ap =>
    l => if (l == "PHP") false else ap(l)

val polyAccept: 
  (Language => Boolean) => (Language => Boolean) =
  ap =>
    l => !ap(l)
```

???
- Having imitated the decorators from before, we can use them

---

Using it

```
val testDocPrice = price andThen testPrice andThen docPrice
val testMC = makeCode andThen testMakeCode
val saneAcc = acceptProject andThen saneAccept

val docPr = price andThen docPrice
val polyAcc = acceptProject andThen polyAccept

testDocPrice(p) // 600
testMC(p)(40) // 150
saneAcc(p)("PHP") // false

docPr(p) // 300
polyAcc(p)("PHP") // false
```

???

- We can now imitate the decorator combinations from before
- A decorator combination is just a chain of functions
- Notice that we only create the functions that were actually overridden by the OO decorators
- So there's no need for a base decorator or anything, we just mix and match 
- And the results are just as before
---

 Recap:

- Methods are just functions: `Programmer => A`
- Decorators are functions of type: `A => A`
- Decoration is (almost) function composition:  
`(Programmer => A) andThen (A => A)`  
`-->`  
`Programmer => A`

???
- Where `A` is some type, like `Money` or a function type
- But who said that we have to use the same `A` all over the place? 
- Function composition works just as well with different types.

--
- Generified version:  
`(Programmer => A) andThen (A => B)`  
`-->`  
`Programmer => B`

???

- Here we have more flexibility in what we use as decorators
- To achieve this in the OO version we would have to change the `Programmer` interface for every new function that we want to define
- Which is not a good thing
---

Using a general decorator
```
val shouldHire: Money => Boolean = m => m < 50

val executiveDecision1: Programmer => Boolean =
  price andThen shouldHire

val executiveDecision2: Programmer => Boolean =
  price andThen testPrice andThen shouldHire

executiveDecision1(p) // true
executiveDecision2(p) // false
```

???

- We are creating functions that decide whether we should hire someone or not
- The `shouldHire` is a generic decorator of the new type, it takes `Money` but produces a `Boolean`
- Here we use the new flexibility that we found and use it to change type
- And we can still mix and match the old decorators
- Generally, Using function composition we can take any function chain of the form:
`Programmer => A => (A => B) => (B => C) => ... => (C => D)`
and turn it into a single function `Programmer => D`
- This is a step beyond what we had in the classic decorator, but we are still missing something.
- Although we didn't use it explicitly, in the original decorator, we had access to the value we wrapped. In
```
class DocumentingProgrammer(p: Programmer) extends ProgrammerDecorator(p) {
    override def price: Money = super.price * 10
  }
```
we could actually call whatever we want on `p`. But there's no mention of a `Programmer` down our functions chain.
- So how do we translate it back to our Functional code?

---

A new decorator type
.codeTable[
`(Programmer => A) => (A => Programmer => B) `

`-->`

`Programmer => B`
]

???

- What we see here is the signature of a new decoration operation
- Given a programmer function, on the left
- And given a decorator of the new kind, the one that also has access to a `Programmer` instance
- The part in the middle is the new decorator type
- We need to able to combine the two into a new programmer function, the part on the left
- And since we don't have any programmers at hand, we'll just have to pass the one that we started with
- Let's call the new decoration function that does this `flatAndThen`
- And we can implement it by just following the types

---

Follow the types
```
implicit class Decorator[A](f: Programmer => A) {
  def flatAndThen[B](g: A => Programmer => B): 
    Programmer => B =
    
    p => {
{{content}}
```

.flatAndThenBrace[
```
   }
}
```
]

???
- We'll use an implicit class to "pimp" this function directly on our functions.
- So `f` is the original `Programmer` function
- And `g` is the decorator function
- And this is the return type that we need
- To write down the function we'll just try to "follow the types" (down the rabbit hole) and see where it gets us
- So we need to return a function that takes a `Programmer` and returns something, the programmer is `p`
- Now we have the `f` function, it expects a `Programmer`, and the only one in scope is `p`, so let's use that
--
      val a: A = f(p)
      
{{content}}

???
- The result is some `A`, and that exactly what `g` needs, so let's apply it to `a`
- The `g` function can now consume the `A` value, so we apply it
--
      val pToB: Programmer => B = g(a)
      
{{content}}

???
- The result is a function from a `Programmer` to `B`
- So let's give it `p`, and the result is the `b` that we need
--
      val b: B = pToB(p)
      
{{content}}
--
      b

???
- Notice how the same `p` is used twice, thus making sure that the decorator work on the same programmer.
- With this function we can take any chain of the form:
`Programmer => A => (A => Programmer => B) => (B => Programmer => C) => ... => (C => Programmer => D)`
and turn into a single function `Programmer => D`
- Let's see how we use it

---

Using the new decorator
```
val bonus: Money => (Programmer => Money) =
  m => p => m + p.experience

val withBonus: Programmer => Money =
  price andThen testPrice flatAndThen bonus

withBonus(p) // 70
```

???
- Here we calculate the bonus a programmer gets, for that we need access to the actual programmer instance
- So this is a decorator of the new kind
- And we can mix and match it with the plain decorators

---

Using the new decorator
```
// with enough coffee, even a dead programmer can
// produce code
val deadProgrammer: 
  (Coffee => LOC) => Programmer => (Coffee => LOC) =
  mc => p =>
    c => if (c > 4 * p.coffeeConsumption) mc(c) else 0

val deadMake: Programmer => (Coffee => LOC) =
  makeCode flatAndThen deadProgrammer andThen testMakeCode

deadMake(p)(50) // 0
deadMake(p)(130) // 2850
```

???

- And here's another example using the a more complicated decorator
- In this case, we model a dead programmer, which normally doesn't produce any code
- But with enough coffee, code can be produced anyway
- And what is "enough" is determined by the actual `Programmer` instance that we're working on

---

Combining `Programmer` functions

```
val costEffective: Programmer => Boolean =
  makeCode flatAndThen { mc =>
    price flatAndThen { pr =>
      (p: Programmer) => mc(p.coffeeConsumption) > pr
    }
  }

costEffective(p) // false
```

???

- We can also combine a number of `Programmer` functions.
- We are trying to figure out whether a programmer is cost effective, that is whether he produces more code than his price
- `makeCode` is like a container for a `Coffee => LOC` function value, and `price` is a container for a `Money` value.
- `andThen` and `flatAndThen` help us reach inside the container and manipulate its contents (sounds familiar?).
- The values depend on the `Programmer` instance that we are going to provide in the future.
- Kind of like Dependency Injection.
- But it's becoming a bit clumsy to write, we'll address this issue later on.
- To conclude:
  * OO decoration is similar to FP (flattened) function composition.
  * OO decoration works well when we have a fixed set of functions and many types of data.
  * FP decoration works well when we have a fixed set of data types and many functions to calculate over them.
  * Because of how function composition works, when used in the right context, FP decoration is much more flexible and lightweight than the OO counterpart.

---
layout: false
class: center, middle, transition

.boromir[![](boromir.jpg)]


---

layout: true

## The Interpreter Pattern

---


???
- The interpreter pattern is used when your language does not provide you with the right level of abstraction for the task at hand.
- So you create your own Domain-Specific Language and embed it in the host language.
- Nothing particularly OO about this. Typically, you represent the language as a `Composite`, and you interpret it using a `Visitor`.
- Both patterns are pretty much lifted from FP, so we'll skip the OO implementation this time.
- Scala has a number of ways to create DSLs, e.g.: higher order functions, macros, string interpolators.
- We'll try to come up with a way that works particularly well with separating the language from its interpretation.

--
The domain:

- Drink coffee
- Write code
- Compile
- Commit code
- Bang head on keyboard

???

- We would like to interconnect the different actions, so that one leads to another.
- We also want to have interaction with the outer world.
- For example, compilation produces some response from outside, and based on this response we choose the next action.
- But we do not want our language to know anything about how to obtain the responses, the interpreter will be responsible for that.
- And this is the domain that we'll be modeling
---

The domain:

```
sealed trait ProgAction


{{content}}
```

???
- The domain is modeled by `ProgAction`
- Each action in the domain becomes a case class of type `ProgAction`

--
case class DrinkCoffee(c: Cups, 
                       next: Coffee => ProgAction) 
  extends ProgAction
  
case class WriteCode(c: Coffee, 
                     next: Code => ProgAction)
  extends ProgAction
  
case class Compile(c: Code, 
                   next: CompileResponse => ProgAction)
  extends ProgAction
  
case class CommitCode(c: Code) extends ProgAction
  
case object BangHeadOnKeyboard extends ProgAction

???
- For example, `DrinkCoffee` specifies how many cups we want to drink 
- And expects a continuation function that accepts the coffee that we just drank
- Based on the input coffee, we choose the next action
- Similarly for `WriteCode` and `Compile`, we specify some parameter and then await a response in the continuation where we choose the next action
- `CommitCode` and `BangHeadOnKeyboard` are final actions, since they don't have a continuation
---

The domain:

```
sealed trait CompileResponse

case class WaitTime(t: Time) extends CompileResponse
case object Exception extends CompileResponse
case object ScaryTypeException extends CompileResponse
```

???
- The `Compile` action takes a `CompileResponse` which can be one of the following cases
- Where a `ScaryTypeException` is something like

---
class: scaryTypeException

`ScaryTypeException`:

```
5862.scala:36: error: type mismatch;
found : scala.collection.mutable.Iterable[_ >: (MapReduceJob.this.DataSource,
scala.collection.mutable.Set[test.TaggedMapper[_, _, _]]) with test.TaggedMapper[_$1,_$2,_$3]
forSome { type _$1; type _$2; type _$3 } <: Object] with
scala.collection.mutable.Builder[(MapReduceJob.this.DataSource,
scala.collection.mutable.Set[test.TaggedMapper[_, _, _]]) with test.TaggedMapper[_$1,_$2,_$3]
forSome { type _$1; type _$2; type _$3 },
scala.collection.mutable.Iterable[_ >: (MapReduceJob.this.DataSource,
scala.collection.mutable.Set[test.TaggedMapper[_, _, _]]) with test.TaggedMapper[_$1,_$2,_$3]
forSome { type _$1; type _$2; type _$3 } <: Object] with
scala.collection.mutable.Builder[(MapReduceJob.this.DataSource,
scala.collection.mutable.Set[test.TaggedMapper[_, _, _]]) with test.TaggedMapper[_$1,_$2,_$3]
forSome { type _$1; type _$2; type _$3 },
cala.collection.mutable.Iterable[_ >: (MapReduceJob.this.DataSource,
scala.collection.mutable.Set[test.TaggedMapper[_, _, _]]) with test.TaggedMapper[_$1,_$2,_$3]
forSome { type _$1; type _$2; type _$3 } <: Object] with
scala.collection.mutable.Builder[(MapReduceJob.this.DataSource,
scala.collection.mutable.Set[test.TaggedMapper[_, _, _]]) with test.TaggedMapper[_$1,_$2,_$3]
forSome { type _$1; type _$2; type _$3 },
scala.collection.mutable.Iterable[_ >: (MapReduceJob.this.DataSource,
scala.collection.mutable.Set[test.TaggedMapper[_, _, _]]) with test.TaggedMapper[_$1,_$2,_$3]
forSome { type _$1; type _$2; type _$3 } <: Object] with
scala.collection.mutable.Builder[(MapReduceJob.this.DataSource,
scala.collection.mutable.Set[test.TaggedMapper[_, _, _]])
...
```

and so on for another 200 lines

---

A sample program

```
val prog: ProgAction =
  DrinkCoffee(3,
    coffee => WriteCode(coffee,
      code => Compile(code,
        compileResponse => compileResponse match {
          case WaitTime(_) => CommitCode(code)
          case _ => BangHeadOnKeyboard
        })))
```

???
- The sample program does the following:
  * We ask for three cups of coffee
  * We use the input coffee to write code
  * The resulting code is compiled
  * If the response is just waiting, we wait and then commit the code
  * Otherwise, we bang our head on the keyboard
---

Combining smaller programs

```
val drinkWrite: ProgAction =
  DrinkCoffee(3,
    coffee => WriteCode(coffee,
      code => ???
    ))

val compile: Code => ProgAction =
  code => Compile(code, compileResponse => ???)

drinkWrite next compile
```

???

- But we have a problem, what if we want to write snippets of actions and combine them together.
- The first snippet just drinks and writes, and the second just compiles
- And we want to combine them like so
- We don't have a `next` function.
- Nor do the types work out even if we did.
- And what do we put instead of the `???`?
- The first snippet worked because we ended with either `CommitCode` or `BangHeadOnKeyboard`, both of those do not require any further actions.
- But that's not the case with the other actions, we can't finish a snippet with any of those.
- Let's loosen up the types a little bit, and see whether we can make this work.

---

A generified domain
```
sealed trait ProgAction[+A]


case class DrinkCoffee[A](c: Cups, next: Coffee => A) 
  extends ProgAction[A]
  
case class WriteCode[A](c: Coffee, next: Code => A) 
  extends ProgAction[A]
  
case class Compile[A](c: Code, next: CompileResponse => A) 
  extends ProgAction[A]
  
case class CommitCode(c: Code) extends ProgAction[Nothing]

case object BangHeadOnKeyboard extends ProgAction[Nothing]
```

???
- This is the same as before, except that the continuations return a generic value

- Now that the type is general, maybe we can use it to stub out arbitrary chains

- For this purpose, we are going to introduce some glue.

---

The glue

```
sealed trait Program[+A]


case class Return[A](a: A) extends Program[A]

case class Glue[A](pa: ProgAction[Program[A]]) 
  extends Program[A]
```

???

- A `Program` is just a wrapper around some value of type `A`.
- `Glue` sticks pieces of `ProgAction`s together, and `Return` lets us stub out a chain, returning the contained value.
- Let's see that in an example

---

Using `Program`
```
val drink: Program[Coffee] =
  Glue(
    DrinkCoffee(3,
      coffee => Return(coffee)))

val drinkWrite: Program[Code] =
  Glue(
    DrinkCoffee(1,
      coffee => Glue(
        WriteCode(coffee,
          code => Return(code)))))
```

???
- Each `Program` snippet contains the response for the action wrapped in a `Return`
- And the generic value of the `Program` becomes the thing that we `Return`

- Stubbing done, what about the `next` function?

---

Composing `Program`s

```
val drinkWrite: Program[Code]
val compile: Code => Program[CompileResponse]

val drinkWriteCompile: Program[CompileResponse] = 
  drinkWrite next compile

{{content}}
```
???
- Using the language of `Program`, we have the following types:
- A program that produces `Code`
- A function that take `Code` and produces a `Program` of a `CompileResponse`
- If we generalize these types, we see that our `next` function should have the following signature
--
def next[A, B]: 
  Program[A] => (A => Program[B]) => Program[B]

???
- `next` should reach into our program, fetch the `A` value, apply a function to it, and produce a new `Program`.

---

`next` implementation

```
sealed trait Program[+A] {
  def next[B](f: A => Program[B]): Program[B] = 
    this match {
      case Return(a) => f(a)
      
      case Glue(pa: ProgAction[Program[A]]) => ???
    }
}
```

???

- We code `next` as a method on `Program`. Start with the easy case, `Return`.
- If we see a `Return`, we unwrap it, apply the function and return its result.
- The `Glue` case is more difficult, because the `A` value is hidden inside a `ProgAction[Program[A]]`.
- We need some way to reach into the `ProgAction` and apply the function there.

---

Operating inside `ProgAction`
```
def map[A, B]: ProgAction[A] => (A => B) => ProgAction[B]
```

???

- We can generalize the type a little.
- Which reads as: reach into the `ProgAction`, apply the function there, and rewrap it back into a `ProgAction`.
- With these types, there is only one reasonable way to implement this function.

--

```
sealed trait ProgAction[+A] {
  def map[B](f: A => B): ProgAction[B] = this match {
    case DrinkCoffee(c, next: (Coffee => A)) => 
      DrinkCoffee(c, next andThen f)
      
    case WriteCode(c, next: (Code => A)) => 
      WriteCode(c, next andThen f)
      
    case Compile(c, next: (CompileResponse => A)) =>
      Compile(c, next andThen f)
      
    case CommitCode(c) => CommitCode(c)
    
    case BangHeadOnKeyboard => BangHeadOnKeyboard
  }
}
```

???

- We do it as a method on `ProgAction`:
- Any `ProgAction` that has a `next` function, just composes `f` after its own `next`.
- The final `ProgAction`s ignore it altogether.

---

`next` implementation

```
sealed trait Program[+A] {
  def next[B](f: A => Program[B]): Program[B] = this match {
    case Return(a) => f(a)
    
    case Glue(pa: ProgAction[Program[A]]) => {
      val progActionB: ProgAction[Program[B]] =
        pa map { (p: Program[A]) =>
          val pb: Program[B] = p next f
          
          pb
        }
        
      Glue(progActionB)
    }
  }
}
```

???
- Now that we can reach into our `ProgAction`s, we can complete the definition of `next`.
- We now `map` into `Glue` and pass the `f` function to the `Program` inside
- This way we recursively apply `f` until we either hit a `Return` or a final `ProgAction`.
- This is a bit tricky to wrap your head around, but by following the types this kind-of writes itself

---

Composing `Program`s
```
val write: Program[Code] =
  Glue(WriteCode(3, code => Return(code)))

val compile: Code => Program[CompileResponse] =
  code => 
    Glue(Compile(code, compileResp => Return(compileResp)))

val writeCompile: Program[CompileResponse] =
  write next compile
```


???

- Finally, we can compose our `ProgAction`s.
- It works!
- Or at the very least it compiles, though that's most of what you need when you program by "following the types".
- But those references to `Glue`s are quite annoying, let's try to hide them away.

---

The `Program` primitives

```
def ret[A](a: A) = Return(a)

val drinkCoffee: Cups => Program[Coffee] =
  cups => Glue(DrinkCoffee(cups, coffee => ret(coffee)))

val writeCode: Coffee => Program[Code] =
  coffee => Glue(WriteCode(coffee, code => ret(code)))

val compile: Code => Program[CompileResponse] =
  code => Glue(Compile(code, cr => ret(cr)))

val bangHeadOnKeyboard: Program[Nothing] =
  Glue(BangHeadOnKeyboard)

val commitCode: Code => Program[Nothing] =
  code => Glue(CommitCode(code))
```

???
- We can factor out the `Glue`s into a bunch of primitive functions, one for every action we have.
- For each primitive, we wrap it with a `Glue` and `Return` the value it gets in the continuation
- There's a common pattern here, which can be factored into a separate function, I'll leave it as an exercise (you can see the solution in the repository).
---

Examples

```
val writeCompile: Program[CompileResponse] = 
  writeCode(3) next compile
```


???

- Since we wrapped all of our primitives, we can create any `Program` we want using our primitives.

- And we can now write more complicated descriptions of programmers.

---

Examples

```
val idealProgrammer: Program[Code] =
  drinkCoffee(1) next writeCode next { code =>
    compile(code) next { response =>
      response match {
        case WaitTime(_) => ret(code)
        
        case Exception => idealProgrammer
        
        case ScaryTypeException => idealProgrammer
      }
    }
  }
```

???
- The ideal programmer just keeps writing code until it compiles and does not abuse coffee.

---

Examples

```
val nervousProgrammer: Program[Code] =
  drinkCoffee(1) next writeCode next { code =>
    compile(code) next { response =>
      response match {
        case WaitTime(t) => 
          drinkCoffee(3 * t) next (_ => ret(code))
          
        case Exception => 
          drinkCoffee(2) next (_ => nervousProgrammer)
          
        case ScaryTypeException => bangHeadOnKeyboard
      }
    }
  }
```

???
- The nervous programmer abuses coffee, without actually turning it into code...

- Now that we have a language, it would be a bit pointless if we don't do something with it.

- Let's hack up an interpreter for it.

- Our interpreter is just a pretty printer.

---

A pretty printer

```
def print(p: Program[_]): Unit = p match {
  case Return(a) => println(a)
  
  case Glue(pa) => pa match {
    case DrinkCoffee(cups, next) =>
      println(s"Drink coffee: $cups")
      print(next(cups * 3))
    case WriteCode(cofee, next) =>
      println(s"Write with $cofee coffee")
      print(next(randomCode()))
    case Compile(code, next) =>
      println(s"Compile: '$code'")
      print(next(codeToResponse(code)))
    case CommitCode(code) => 
      println(s"Commit: '$code'")
    case BangHeadOnKeyboard =>
      println("Bang head on keyboard")
  }
}
```

???
- Writing an interpreter is straightforward, just follow the possible cases one by one
- In here, we follow the steps of our program and supply the appropriate input values
---

A pretty printer

```
def randomCode(): Code = 
  Random.shuffle(codeToResponse.keys.toList).head

val codeToResponse = Map(
  "java code" -> WaitTime(1),
  "scala code" -> WaitTime(20),
  "implicits spaghetti" -> WaitTime(400),
  "null abuse" -> Exception,
  "higher kinded madness" -> ScaryTypeException)
```

???
- For each bit of code, we have some compilation response
- As you can see, Java code compiles quite quickly, unlike Scala...
- And we can run our programs
---

```asciidoc
print(idealProgrammer next commitCode)

Drink coffee: 1
Write with 3 coffee
Compile: 'higher kinded madness'
Drink coffee: 1
Write with 3 coffee
Compile: 'java code'
Commit: 'java code'
```

```asciidoc
print(nervousProgrammer next commitCode)

Drink coffee: 1
Write with 3 coffee
Compile: 'null abuse'
Drink coffee: 2
Drink coffee: 1
Write with 3 coffee
Compile: 'higher kinded madness'
Bang head on keyboard
```

???

- In the same vein, we can write other kinds of interpreters.
- You can see couple of other examples in the repository.
- One counts the amount of coffee the programmer consumes.
- The other fetches the code that the programmer produced.
- We have managed to define a small language using composable parts.
- This sort of composability would be hard to achieve with OO techniques.
- But may be overkill for simpler languages.
- This technique is (way) more general than what we did here.

---
layout: false
class: center, middle, transition

.toy_story[![](toy_story.jpg)]

???


- Remember how way back on one of the first slides we dissed design patterns?

- Let's drop the "design" and just look for patterns.

- Do we see any in the different FP examples thus far?

---
layout: true

## Design Patterns - Redux

---


A common pattern

.smallCode[
```
type ForProg[A] = Programmer => A

def flatMap[A, B]:     List[A]    => (A => List[B])    => List[B]
def flatMap[A, B]:     Option[A]  => (A => Option[B])  => Option[B]
def flatAndThen[A, B]: ForProg[A] => (A => ForProg[B]) => ForProg[B]
def next[A, B]:        Program[A] => (A => Program[B]) => Program[B]
```
]

???
- By looking only at the signatures we can easily spot a repetitive pattern

--

```
def flatMap[A, B]: M[A] => (A => M[B]) => M[B]
```

???

- This is what's left after we abstract away the wrapper type

--

Monads!

- .smallCode[`Programmer => A`] is an instance of the Reader monad.
- .smalCode[`Program[A]`] is an instance of the Free monad.

???

- Things like `M` actually have a name, which comes from abstract math, they are called Monads.

- With the Free monad you can do a whole lot more than just interpreters, but that's a whole topic in itself.

---
class:monadsList

Monads on the web:

--

- [Monads are like elephants](http://james-iry.blogspot.com/2007/09/monads-are-elephants-part-1.html)

--
- [Monads are like space suits](http://web.archive.org/web/20081206204420/http://www.loria.fr/~kow/monads/index.html)

--
- [Monads are like monsters](http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html)

--
- [Monads are like burritos](http://blog.plover.com/prog/burritos.html)

--
- [Monads are like a space suit full of nuclear waste in the ocean next to a container of apples](http://koweycode.blogspot.co.il/2007/01/think-of-monad.html)

--
- [Monads are not metaphors](http://www.codecommit.com/blog/ruby/monads-are-not-metaphors)

--
- [You could have invented monads! (and maybe you already have)](http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html)

--
- [Bob the monadic lover](http://www.haskell.org/haskellwiki/Meet_Bob_The_Monadic_Lover)

--
- [A monad is a programmable semicolon](http://blog.vmchale.com/article/programmable-semicolon)

--
- [The monad tutorial fallacy](http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/)

--
- [~~Monads~~ Warm fuzzy things](https://www.urbandictionary.com/define.php?term=Warm%20Fuzzy%20Thing)

--
- [A monad is just a monoid in the category of endofunctors](http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem)

???

- So I won't be explaining monads in this lecture.

- But I will give you some motivation on why you should care about them.

- Once you figure out that something is a monad, you can apply generic monad functions on it.

- A concrete example in Scala is the `for` syntax.

- The `for` syntax is provided for free for anything that can be regarded as a monad.

- Specifically, anything that supports `flatMap` (and `map`).

- We can rewrite some of the code from before with `for` notation (the full code is in the repository).

---

Monadic `for`

```
val costEffective: Programmer => Boolean =
  for {
    mc <- makeCode
    pr <- price
    p <- getProgrammer
  } yield mc(p.coffeeConsumption) > pr
```

???
- This translates to exact code that we've written using `andThen` and `flatAndThen`
- But just like with `List`s and `Option`s using the `for` syntax is sometimes more readable
- Especially if you have a number of chained steps
- We can do something similar with the `Program`s from the previous part
---

Monadic `for`
```
def nervousProgrammer: Program[Code] =
  for {
    code <- drinkCoffee(1) next writeCode
    response <- compile(code)
    finalCode <- response match {
      case WaitTime(t) => 
        drinkCoffee(3 * t) next (_ => ret(code))
        
      case Exception => 
        drinkCoffee(1) next (_ => nervousProgrammer)
        
      case ScaryTypeException => bangHeadOnKeyboard
    }
  } yield finalCode
```
???

- Monads are one of the many mathematical structures that are used in Functional programming.

- Different code patterns, become mathematical structures.

- These are the equivalents of design patterns in FP.

- Looking around for these patterns, can greatly improve the design of our code.

---
layout: false
class: center, middle, transition

.xkcd[![](xkcd.png)]

.xkcdTitle[
>Functional programming combines the flexibility and power of abstract mathematics with the intuitive clarity of abstract mathematics.
]


.questions[
Questions?
]

  </textarea>
	<script
		src="remark-0.14.0.min.js"
		type="text/javascript">

	</script>
	<script type="text/javascript">
    var slideshow = remark.create({ highlightLanguage: 'scala', highlightStyle: 'magula'});
    //document.addEventListener('click', function (e) { slideshow.gotoNextSlide() }, false);
	</script>
</body>
</html>
